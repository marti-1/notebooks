[Turing Machines and Decision Problems](https://www.youtube.com/watch?v=e-lruZ3z8ik&ab_channel=TexTalks)

Suppose a set of numbers with non-trivial factors:

FACTORING = {4,6,8,9,10,12,14,15,16,18,...}

Recall we have a finite alphabet $\Sigma$ (from Turing machine). Define $\Sigma^*$ to be the collection of all finite strings of characters from $\Sigma$:

$\Sigma = \{0,1,2,3,4,5,6,7,8,9\}$

$\text{FACTORING} \subseteq \Sigma^*$

Def: A **decision problem** (otherwise known as a language) is any subset $L \subseteq \Sigma^*$. Intuitively, decision is $x \in L$.

Def: Let L be a language, M be a TM. We say that M decides L iff (computes, solves):
* if $x\in L$ then M accepts x in k steps;
* if $x\notin L$ then M rejects x in k steps.

[The Halting Problem and Uncomputability](https://www.youtube.com/watch?v=73mY82UOclc&ab_channel=TexTalks)

Note, computable < Turing machine.

[Computable Enumerability Revisited](https://www.youtube.com/watch?v=gzc89VL9rcc&ab_channel=TexTalks)

Fact: $R \subseteq RE$. 

_(My intuition is that a machine that can simulate RE can simulate R, but not vice versa)_

[The Halting Problem is RE-complete](https://www.youtube.com/watch?v=VvKcxu9bFR4&ab_channel=TexTalks)

$R \neq RE$. Halting problem $H \notin R$. However, it is in RE.

[Dual Classes, coRE, and Exhaustive Checking](https://www.youtube.com/watch?v=VOb4RNE56xU&t=246s&ab_channel=TexTalks)

**RE definition**: $x \in L \Leftrightarrow \exists y[(x,y) \in J]$ where $J$ is computable. It makes sense to look at it from degress of separation from computability. In this case it would be 1st degree uncomputable.

$\exists$ -- unbounded search. $\forall$ -- exhaustive check.

Fact: [coR = R](https://youtu.be/VOb4RNE56xU?si=AVTH6i5jD4TnkUjL&t=634).

**coRE definition**: $x \in L \Leftrightarrow \forall y[(x,y) \notin J]$ where $J$ is computable.

Satisfiability in first-order logic is RE -- if you can find one assignment that works, you are done.

Validity is coRE -- you need to check that all assignments work.

Fact: $\text{coRE} \cap \text{RE} = R$. coRE always halts if the answer is no. RE always halts if the answer is yes. The conjunction of two is decidable:

1) Input x, k=1
2) Run coRE for x for k steps
3) if "no" is returned, return "no"
4) Run RE for x for k steps
5) if "yes" is returned, return "yes"
6) k=k+1
7) go to 2

In case of a machine $M_S$ for satisfiability and $M_V$ for validity, the conjunction would be the decision if some assignment $\phi$ is true or false.

Since $\text{RE} \neq \text{R}$, and $\text{coRE} \cap \text{RE} = R$, it follows that $\text{coRE} \neq \text{RE}$.

Likewise $R \neq \text{coRE}$, since $\text{R} = \text{coR}$, but $\text{RE} \neq \text{coRE}$.

[The Arithmetic Hierarchy](https://www.youtube.com/watch?v=V2FuoozVm0k&ab_channel=TexTalks)


* Layer 0: $\Delta_1 = R$
* Layer 1: $\Sigma_1 = \text{RE}$, $\Pi_1 = \text{coRE}$

Note, $\Delta_0 < \Delta_1$, and it is a class of primitive recursive functions.

$\Sigma_2$ is defined as $x \in L \Leftrightarrow \exists y_1 \forall y_2[(y_1,y_2,x) \in J]$ where $J$ is computable. For example, "there exists and interpretation $I$ in which $J$ is true".

```
def exists(p):
    for y in range(1, infinity):
        if p(y):
            return True

def forall(p):
    for y in range(1, infinity):
        if not p(y):
            return False

def sigma2(x):
    return exists(lambda y1: forall(lambda y2: J(y1, y2, x)))
```

$\Pi_3$: $x \in L \Leftrightarrow \forall y_1 \exists y_2 \forall y_3[(y_1,y_2,y_3,x) \in J]$. 

<img src="https://diagonalargument.com/wp-content/uploads/2020/10/arith-hierarchy.png" height="300">

---

Personal observation. A successive quantifiers of the same time "collapse". For example, if we have $\exists y_1 \exists y_2: [(y_1,y_2,x) \in J]$, then:

```
for (y1, y2) in product(range(1, infinity), range(1, infinity)):
    if J(y1, y2, x):
        return True
```

So to get to the next degree of computability, we need to "layer" another type of quantifier. In the above case, that would be $\forall$.

[Languages and Formal Grammars](https://www.youtube.com/watch?v=cdudDfXKrUc&t=530s&ab_channel=TexTalks)

Language is modeled as an automaton that is defined as tuple $G = (T, N, R)$, where $T$ is a set of terminals, $N$ is a set of non-terminals, and $R$ is a set of rules.

The language $L$ generated by $G$ is the set of all strings of terminals which have derivates from $G$.

[Example](https://youtu.be/cdudDfXKrUc?si=xZDozaL61gn78qmA&t=619).

Hierarchy of grammars is called **Chomsky hierarchy**.

[Languages and Decision Problems](https://www.youtube.com/watch?v=meYJUEyitaY&ab_channel=TexTalks)

Theorem: A language $L$ can be specified by a formal grammar iff it is computably enumerable.

Informal proof:
- (a language $L$ can be specified by a formal grammar -> it is c.e.) -- you can code up Turing machine to generate the language from the rules and alphabet.
- (If c.e. -> a language $L$ can be specified by a formal grammar) -- formal grammar is Turing complete. The proof would encode universal Turing machine using formal grammar.

Corollary: **If you can describe an infinite set finitely then the set is computably enumerable**.

[Let's Define Definability](https://www.youtube.com/watch?v=KRlFIm4AmJM&t=22s&ab_channel=TexTalks)

[There are sets that are not definable](https://youtu.be/KRlFIm4AmJM?si=bRej53gen8U4waEs&t=632). There is uncountably many infinite bit strings. Meanwhile, the set of all wffs is countable.

[Another Arithmetic Hierarchy?](https://www.youtube.com/watch?v=F6ZFzj-nao0&t=135s&ab_channel=TexTalks)

$\Sigma_k$ is equivalent to the form $\exists x_1 \forall x_2 \exists x_3 \dots Q x_k \phi$, where $Q$ is $\exists$ if $k$ is odd, and $\forall$ if $k$ is even, and $\phi$ is $\Delta_0$.

Note, if $\phi$ is $\Sigma_k$ then it is also $\Sigma_{k+1}, \Pi_{k+1}, \Sigma_{k+2}, \Pi_{k+2},\dots$, because you can always add useless quantifiers. For example, $\exists z \forall x \exists y [x < y]$.

**Since every formula is equivalent to a set, the previous hierarchy of formulas is a hierarchy of sets.**

[Showing that the Two Arithmetic Hierarchies are the Same](https://www.youtube.com/watch?v=gQ1Smowea04&t=23s&ab_channel=TexTalks)

Ex: Here is a $\Delta_0$ formula: $Q(y) = \exists x_{<20}(3x > y)$. To check, just compute 3x for each x < 20, and compare with y. If we find one bigger, halt and accept. Else reject. Thus by the Church-Turing thesis, $\Delta_0 \subseteq R$.

Likewise, here is a $\Sigma_1$ formula: $Q(y,z) = \exists x(x^2+y^2+z^2=1)$. Given a $y$ and a $z$, we can easily compute $x^2+y^2+z^2$ for each $x$, one at a time, stopping if we find one such that it is equal to 1. Thus, by Church-Turing thesis: $\Sigma_1 \subseteq  \text{RE}$.

Theorem: $\Sigma_1 = \text{RE} = \Sigma_1$. $\Pi_1 = \text{coRE}$  Also, $R=\Delta_1$. Consequently, thw two definitions of the arithmetic hierarchy are the same.

Proof: We need to show that (1) $\Sigma_1 \subseteq \text{RE}$ and (2) $\text{RE} \subseteq \Sigma_1$. The (1) comes from the CT thesis. The (2) comes from the fact that we can express a Turing machine as a recursive formula.

Who is to say that [$\Delta_1 \neq \Sigma_1$](https://youtu.be/gQ1Smowea04?si=zMgqMw40qsTlmQGC)? This has been already proven, by showing that there is a Halting problem $H$ which is in RE but not in R. Thus if I view the Halting problem as a set of numbers, then I have a set that is definable as a $\Sigma_1$ formula, but not definable as a $\Delta_1$ formula.

[Footnote: Primitive Recursion and Normie Recursion](https://www.youtube.com/watch?v=tKih3PGAyck&t=5s&ab_channel=TexTalks)

- Primitive recursive -- I know **when** it will end.
- Recursive -- I know it will end.

[The Final Domino: Proving Things is Computably Enumerable](https://www.youtube.com/watch?v=ZAE7W18O8Yc&ab_channel=TexTalks)

$\text{PROOFS}_{\Gamma} \subseteq \text{RE}$.

[FINALE: GÃ¶del's First Incompleteness Theorem](https://www.youtube.com/watch?v=SDeVsAjiuwM&ab_channel=TexTalks)

If we accept the fact that there is an arithmetical hierarchy which is an infinite number of steps in computational complexity, then the truth predicate is not definable in arithmetic. If it was, it would be defined at some level $k$. However, because of that all the levels $>k$ would collapse into $k$.
